import sys
from typing import (
    Any,
    Callable,
    Dict,
    Generic,
    Iterator,
    IO,
    List,
    Optional,
    Sequence,
    Tuple,
    Type,
    TypeVar,
    Union,
    overload,
    Iterable,
    Sized
)
import builtins

import numpy.random

# Some type differences under python3
if sys.version_info[0] >= 3:
  long = int
  buffer_type = memoryview
else:
  buffer_type = buffer

# generic is the base class of all the types that an ndarray can have
class generic:
    @property
    def dtype(self: _DTypeObj) -> _dtype[_DTypeObj]: ...
    def astype(self, dtype: Type[_DType]) -> _DType: ...

_Number = TypeVar("_Number", bound=number)

class number(generic):
    def copy(self: _Number) -> _Number: ...

# a smaller-bit integer can act like a bigger integer in the sense that if you add an int16 and an
# int64, then numpy will upgrade the int16 to an int64 and add them
# and this is why we let int32 be a subclass of int64; and similarly for float32 and float64
class floating(number, float): ...
class float64(floating): ...
class float32(float64): ...
class integer(number, int): ...
class int64(integer): ...
class int32(int64): ...
class int16(int32): ...
class int8(int16): ...
class bool_(int8): ...
class str_(generic, str): ...
class object_(generic): ...
class inexact(number, float): ...
class complexfloating(inexact): ...
class complex128(complexfloating): ...

_DType = TypeVar("_DType", bool_, float32, float64, int8, int16, int32, int64, complex128, str_, covariant=True)
_DType2 = TypeVar("_DType2", bool_, float32, float64, int8, int16, int32, int64, str_)
_DTypeObj = TypeVar("_DTypeObj", bound=Union[generic, int, float])
_ShapeType = Union[int, Tuple[int, ...], List[int]]
_AxesType = Union[int, Tuple[int, ...], List[int]]
# _InterpolationType = Literal["linear", "lower", "higher", "midpoint", "nearest"]
_OrderType = Union[str, Sequence[str]]
_ScalarLike = Union[_DType, str, int, float]
_ConditionType = Union[ndarray[bool_], bool_, bool]
newaxis: None = ...

_AnyNum = Union[int, float, bool]
# generic types that are only allowed to take on dtype values

_Float = TypeVar("_Float", float32, float64)
_FloatObj = TypeVar("_FloatObj", bound=Union[floating, float])
_Int = TypeVar("_Int", bool_, int8, int16, int32, int64)
_IntObj = TypeVar("_IntObj", bound=Union[integer, int])
_BoolObj = TypeVar("_BoolObj", bound=Union[bool_, bool])

_NestedList = Union[List[_T], List[List[_T]], List[List[List[_T]]], List[List[List[List[_T]]]]]

class dtype(Generic[_DTypeObj]):
    def __init__(self: dtype[_DTypeObj], obj: Type[_DTypeObj]) -> None: ...
    def __init__(self, obj: str) -> None: ...
    def type(self) -> Type[_DTypeObj]: ...

_dtype = dtype

class ndarray(Generic[_DType], Sized):
  # https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html
  def __init__(self,
               shape,
               dtype=...,
               buffer=...,
               offset=...,
               strides=...,
               order=...) -> None: ...

  def __getattr__(self, name) -> Any: ...

  # We need to add all special methods used for protocols explicitly
  # (b/33779140). Everything else is optional.

  # https://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#array-attributes
  @property
  def flags(self) -> Any: ...
  @property
  def shape(self) -> Tuple[int, ...]: ...
  @property
  def strides(self) -> Tuple[int, ...]: ...
  @property
  def data(self) -> buffer_type: ...
  @property
  def size(self) -> int: ...
  @property
  def itemsize(self) -> int: ...
  @property
  def nbytes(self) -> int: ...
  @property
  def base(self) -> Optional[ndarray]: ...

  @property
  def T(self) -> ndarray[_DType]: ...
  @property
  def real(self) -> ndarray[_DType]: ...
  @property
  def imag(self) -> ndarray[_DType]: ...
  @property
  def flat(self) -> Any[_DType]: ...
  @property
  def ctypes(self) -> Any[_DType]: ...
  @property
  def __array_interface__(self) -> dict: ...

  # TODO(b/159138694): add array methods:
  # https://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html#array-methods
  # def reshape(self, *newshape) -> ndarray: ...
  def reshape(self, newshape, order = ...) -> ndarray[_DType]: ...
  def conj(self) -> ndarray[_DType]: ...
  def squeeze(self, axis = ...) -> ndarray[_DType]: ...
  def ravel(self, order = ...) -> ndarray[_DType]: ...
  def copy(order=...) -> ndarray[_DType]: ...
  def astype(self, dtype: Type[int], order=..., casting=..., subok=..., copy=...) -> ndarray[int32]: ...
  def astype(self, dtype: Type[_DType2], order=..., casting=..., subok=..., copy=...) -> ndarray[_DType2]: ...

  # https://docs.python.org/2/reference/datamodel.html
  def __len__(self) -> int: ...
  def __getitem__(self, key) -> Any: ...
  def __setitem__(self, key, value): ...
  def __iter__(self) -> Any: ...
  def __contains__(self, key) -> bool: ...
  def __reversed__(self) -> Iterator[Any]: ...

  # __getitem__ should suffice here, but pytype needs these (b/65407594)
  def __getslice__(self, i, j) -> Any: ...
  def __setslice__(self, i, j, value) -> Any: ...

  def __complex__(self) -> complex: ...
  def __int__(self) -> int: ...
  def __long__(self) -> long: ...
  def __float__(self) -> float: ...
  def __oct__(self) -> str: ...
  def __hex__(self) -> str: ...
  def __nonzero__(self) -> bool: ...

  def __index__(self) -> int: ...

  def __copy__(self, order = ...) -> ndarray[_DType]: ...
  def __deepcopy__(self, order = ...) -> ndarray[_DType]: ...

  # https://github.com/numpy/numpy/blob/v1.13.0/numpy/lib/mixins.py#L63-L181

  # TODO(b/159138694): add overloads (returning ndarray) for cases where other
  # is known not to define __array_priority__ or __array_ufunc__, such as for
  # numbers or other numpy arrays. Or even better, use protocols (once they
  # work).

  def __lt__(self, other): ...
  def __le__(self, other): ...
  def __eq__(self, other): ...
  def __ne__(self, other): ...
  def __gt__(self, other): ...
  def __ge__(self, other): ...

  def __add__(self, other) -> ndarray[_DType]: ...
  def __radd__(self, other): ...
  def __iadd__(self, other): ...

  def __sub__(self, other) -> ndarray[_DType]: ...
  def __rsub__(self, other): ...
  def __isub__(self, other): ...

  def __mul__(self, other) -> ndarray[_DType]: ...
  def __rmul__(self, other): ...
  def __imul__(self, other): ...

  def __div__(self, other) -> ndarray[_DType]: ...
  def __rdiv__(self, other): ...
  def __idiv__(self, other): ...

  def __truediv__(self, other) -> ndarray[_DType]: ...
  def __rtruediv__(self, other): ...
  def __itruediv__(self, other): ...

  def __floordiv__(self, other) -> ndarray[_DType]: ...
  def __rfloordiv__(self, other): ...
  def __ifloordiv__(self, other): ...

  def __mod__(self, other): ...
  def __rmod__(self, other): ...
  def __imod__(self, other): ...

  def __divmod__(self, other): ...
  def __rdivmod__(self, other): ...

  # NumPy's __pow__ doesn't handle a third argument
  def __pow__(self, other): ...
  def __rpow__(self, other): ...
  def __ipow__(self, other): ...

  def __lshift__(self, other): ...
  def __rlshift__(self, other): ...
  def __ilshift__(self, other): ...

  def __rshift__(self, other): ...
  def __rrshift__(self, other): ...
  def __irshift__(self, other): ...

  def __and__(self, other): ...
  def __rand__(self, other): ...
  def __iand__(self, other): ...

  def __xor__(self, other): ...
  def __rxor__(self, other): ...
  def __ixor__(self, other): ...

  def __or__(self, other): ...
  def __ror__(self, other): ...
  def __ior__(self, other): ...

  def __neg__(self) -> ndarray[_DType]: ...
  def __pos__(self) -> ndarray[_DType]: ...
  def __abs__(self) -> ndarray[_DType]: ...
  def __invert__(self) -> ndarray[_DType]: ...

  if sys.version_info >= (3, 5):
    def __matmul__(self, other): ...
    def __rmatmul__(self, other): ...
    def __imatmul__(self, other): ...

def array(object: Any,
          dtype: Type[_DType] = ...,
          copy: bool = ...,
          order: str = ...,
          subok: bool = ...,
          ndmin: int = ...) -> ndarray[_DType]: ...


def asarray(a: Any,
            dtype: Type[_DType] = ...,
            order: Optional[str] = ...) -> ndarray[_DType]: ...


def __getattr__(name) -> Any: ...


def arange(stop, start = ..., step = ...) -> ndarray[int64]: ...
def linspace(
    start: float, stop: float, num: int = ..., endpoint: bool = ...
) -> ndarray[float64]: ...
def tile(a: ndarray[_DType], reps) -> ndarray[_DType]: ...
def exp(a, dtype: Type[_DType]) -> ndarray[_DType]: ...
def ceil(a: ndarray[_DType]) -> ndarray[_DType]: ...
def log(a) -> _FloatObj: ...
def log(a: ndarray[_DType]) -> ndarray[_DType]: ...
def zeros(shape, order = ...) -> ndarray[float64]: ...
def zeros(shape, dtype: Type[_DType] = ..., order = ...) -> ndarray[_DType]: ...
def ones(shape, order = ...) -> ndarray[float64]: ...
def ones(shape, dtype: Type[_DType] = ..., order = ...) -> ndarray[_DType]: ...
def multiply(a, b, dtype: Type[_DType] = ...) -> ndarray[_DType]: ...
def sqrt(a) -> float: ...
def matmul(a: ndarray[_DType], b: ndarray[_DType]) -> ndarray[_DType]: ...
def reshape(a: ndarray[_DType], newshape) -> ndarray[_DType]: ...
def conj(a: ndarray[_DType]) -> ndarray[_DType]: ...
def column_stack(tup: List[ndarray[_DType], ...]) -> ndarray[_DType]: ...
def where(condition) -> List[ndarray[int8], ...]: ... 

# matrix
class matrix(ndarray): ...

def asmatrix(data, dtype: Type[_DType] =...) -> ndarray[_DType]: ...
